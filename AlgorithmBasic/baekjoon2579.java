// https://www.acmicpc.net/problem/2579
/*
DP로 풀면 되는 문제이다.
막 어려운 문제는 아니였지만, 생각보다 규칙을 찾는게 간단하진 않았다.
                       2칸이동해서  1칸이동해서
                       밟았을때     밟았을때
5  arr 20          dp  55+20=75   45+20=65
4      10              35+10=45   55+10=65
3      25              30+25=55   25+25=50
2      15              10+15=25   20+15=35
1      20              0+20=20    10+20=30
0      10              10         10
위 그림처럼 dp배열을 2차원 배열로 만들어서, (그냥 배열2개로 각각 만들어도 됨)
해당 계단을 2칸 전 계단에서 2칸 이동 해서 밟았을 때와, 이전 계단에서 1칸이동해서 밟았을 때 총 2가지 케이스로 나눠서 구하면 된다.
여기서 규칙을 찾아보면 2칸 이동해서 밟았을 때는, 2칸전 계단의 누적 값 중 큰 값을 해당 계단의 값에 더하면되고,
1칸 이동해서 밟았을 때에는 이전 계단의 값 중, 2칸이동해서 밟았을때의 값만 가능하다. (3칸 연속 밟는건 불가능)
해당 규칙을 가지고 식을 만들어서, 반목문을 통해 dp배열에 순차적으로 값을 저장하면서 풀면
최종적으로 마지막 계단을 밟았을 때의 최댓값을 얻을 수 있다.

문제를 푼 시간보다 설명을 작성하는 시간이 더 오래걸렸다..
이런 문제는 글보다는 그림과 말로 설명하면 훨씬 간단할 것 같다.
*/


import java.io.*;

public class baekjoon2579 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        int[] arr = new int[N];
        for(int i = 0; i<N; i++){
            arr[i] = Integer.parseInt(br.readLine());
        }
        int[][] dp = new int[N][2]; // 2차원 dp배열 생성, dp[n][0]은  n-1번째 계단을 2칸이동해서 밟았을때,
                                                    //  dp[n][1]은  n-1번째 계단을 1칸이동해서 밟았을때이다.
        dp[0][0] = arr[0];  // 첫 계단은 계단의 처음 값인 arr[0]
        dp[0][1] = arr[0];  // 첫 계단은 계단의 처음 값인 arr[0]
        if(N>1) {   // 계단이 2개 이상이면,
            dp[1][0] = arr[1];  // 2칸이동해서 밟았을때는 0+arr[1]
            dp[1][1] = arr[1] + arr[0]; // 1칸이동해서 밟았을 때는 arr[1]+arr[0]
        }
        if(N>2){    // 계단이 3개 이상이면 반복문을 통해 구함
            for(int i = 2; i<N; i++){
                dp[i][0] = arr[i]+Math.max(dp[i-2][0], dp[i-2][1]); // 해당 계단을 2칸이동해서 밟았을 때의 최댓값은,
                                                                    // 2칸전 계단의 누적 값들 중 큰 값을 해당 계단의 값을 더한다
                dp[i][1] = arr[i]+dp[i-1][0];   // 해당 계단을 1칸 이동해서 밟았을 때의 최댓값은,
                                                // 이전 계단의 누적값 중 2칸이동해서 밟았을 때의 누적값을 해당 계단의 값에 더한다. (3칸연속이동은 불가능하기 때문)
            }
        }
        System.out.println(Math.max(dp[N-1][0], dp[N-1][1]));   // 마지막 계단의 누적 값중 큰 값을 최종 출력
    }
}